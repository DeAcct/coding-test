// 동적 계획법
// 해결한 작은 문제로 큰 문제를 해결.
// 특정 알고리즘이 아닌 문제 해결 방식이다.

// 메모리를 많이 사용하지만 성능이 빠르다.
// 메모이제이션, 타뷸레이션 두 가지 방식이 있다.

// 메모이제이션
// 하향식 접근법
// 동적 계획법에서 작은 문제들의 결과는 항상 같다.
// 결과들을 메모리에 저장해 필요할 때 꺼내 쓰는 것.
//
// 피보나치 수열에서 가장 작은 문제? 첫 번째와 두 번째 수열.
// 이 작은 문제로 큰 문제를 해결할 수 있는가?
// 규칙이 있다면 가능하다.

// 타뷸레이션
// 상향식 접근법
// 필요한 값들을 미리 계산해 두는것

// 키워드 만으로 동적 계획법 문제임을 알기 어렵다.
// 문제 유형을 알 수 없다면,
// 가장 작은 문제를 정의할 수 있는가?
// 가장 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는가?
// 두 가지가 가능하다면 동적 계획법 문제다.
// 간혹 메모리 과다 사용 문제로 통과할 수 없는 경우가 있음.
// 이 때 백트래킹을 대신 사용한다.

/**
 * 주어진 단어 조각을 최소로 사용하여 목표 단어를 만들 때, 사용된 조각의 수를 구해라.
 * 구할 수 없는 경우 -1을 반환한다.
 * @param {Array<string>} strs 단어 조각의 종류가 들어있는 배열입니다.
 * @param {string} t 단어 조각으로 만들 단어입니다.
 * @returns {number} 사용된 조각의 최솟값를 반환합니다.
 */
function solution(strs, t) {
  // banana를 만들고자 한다면,
  //
  // 가장 작은 문제
  // b를 만들 수 있는 단어 개수의 최솟값
  //
  // 큰 문제
  // ba를 만들 수 있는 단어 개수의 최솟값
  // ban를 만들 수 있는 단어 개수의 최솟값
  // bana를 만들 수 있는 단어 개수의 최솟값
  // ...

  // 편의를 위해 t+1 만큰 배열을 만든다.
  // 자른 단어를 만들 수 있는 조각 개수의 최솟값을 저장하는 배열
  const dp = Array.from({ length: t.length + 1 }, () => 0);
  // 문자열 검사를 빠르게 하기 위해 문자열 리스트를 set으로 만든다.
  const strsSet = new Set(strs);

  // 1부터 문자열 길이 + 1까지 루프를 돈다.
  for (let i = 1; i < t.length + 1; i++) {
    // 해당 문자열의 최솟값을 무한으로 설정한다.
    dp[i] = Infinity;
    // 문자열을 자르면서 단어 조각을 찾기 위해 루프를 돈다.
    // 단어 조각은 길이가 5 이하기 때문에 마지막까지 자를 필요는 없다.
    for (let j = 1; j < Math.min(i + 1, 6); j++) {
      const start = i - j;
      const end = i;
      // 단어 조각이 있다면
      if (strsSet.has(t.slice(start, end))) {
        // 이전 조합과 더해서 최솟값인지 체크 후 대입한다.
        dp[i] = Math.min(dp[i], dp[start] + 1);
      }
    }
  }

  return dp.at(-1) === Infinity ? -1 : dp.at(-1);
}
