// 해시 테이블
// 키와 값을 받아 키를 해싱하여 나온 index에 값을 저장하는 선형 자료구조
// 삽입하는데 O(1)의 시간복잡도, 키를 알고있다면 삭제와 탐색도 O(1)로 수행한다.
// 저장하는 공간을 Bucket이라 부른다.

// 해시 함수
// 입력값을 특정 범위 내 숫자로 변경하는 함수

// 해시 함수의 결과가 동일한 경우 해시 충돌이 발생한다.

// 충돌이 발생할 경우
//
// - 옆으로 한 칸 이동하는 "선형 탐사법"
// 데이터가 한 쪽에 몰리는 현상이 발생할 수 있다.
// 한 칸 이동해도 값이 있는 상황이 계속 발생할 경우 이동이 반복되기 때문에 선형시간이 걸릴 수 있다.
//
// - 충돌이 발생한 횟수의 제곱만큼 옆으로 이동하는 "제곱 탐사법"
//
// - 충돌이 발생할 경우 다른 해시함수를 이용하는 "이중 해싱"
//
// - 버킷의 값을 연결 리스트로 사용하여 충돌이 발생할 경우 리스트에 값을 추가하는 "분리 연결법"
// 연결 리스트가 무한정으로 늘어날 수 있는 단점이 있다.

// 사용처
// - 출석부
// 연결 리스트를 사용하거나, 배열을 사용할 때 학생의 인덱스를 모를 경우 O(n)의 시간복잡도를 가진다.
// 따라서 출석부와 같이 값을 빠르게 찾아야 하는 경우 해시 테이블을 사용하는 것이 좋다.

// 사실, 자바스크립트의 배열과 객체를 해시테이블로 간주해도 된다.
// 배열, 객체 이외에도 Map 객체도 이용할 수 있다.
// Map 객체는 문자열 이외의 타입도 키로 이용할 수 있다.
// Set 객체는 키와 값이 동일하게 저장되는 객체이다. 집합 개념이므로 중복을 제거할 때 사용할 수 있다.

//sample data
const GENRES = ["classic", "pop", "classic", "classic", "pop"];
const PLAYS = [500, 600, 150, 800, 2500];

function solution(genres, plays) {
  const genreMap = new Map();
  genres
    // [장르, 해당 노래 재생수] 꼴로 묶는다.
    .map((genre, i) => [genre, plays[i]])
    .forEach(([genre, play], id) => {
      const data = genreMap.get(genre) || { total: 0, songs: [] };
      genreMap.set(genre, {
        // 장르끼리 묶어 장르별 재생수를 계산한다.
        total: data.total + play,
        // 거기에 해당하는 노래를 저장한다.
        songs: [...data.songs, { play, id }]
          // 노래를 정렬하고
          .sort((a, b) => b.play - a.play)
          // 2개 이하로 유지한다.
          .slice(0, 2),
      });
    });

  return (
    [...genreMap.entries()]
      // 총 재생수를 기반으로 정렬한다.
      .sort((a, b) => b[1].total - a[1].total)
      // 노래 id만 배열에 남기기
      .reduce((arr, [_, { songs }]) => [...arr, ...songs], [])
      .map(({ id }) => id)
  );
}
console.log(solution(GENRES, PLAYS));
