// 그래프
// 정점(Node)과 정점 사이를 연결하는 간선(Edge)으로 이루어진 비선형 자료구조
// 정점 집합과 간선 집합으로 표현할 수 있다.
// 지하철 노선도, 검색 알고리즘

// 정점은 여러 개의 간선을 가질 수 있다.
// 방향 그래프, 무방향 그래프로 나눌 수 있다.
// 간선은 가중치(예를 들어, 도시와 도시 사이를 잇는다면 그 도로의 길이)를 가질 수 있다.
// 탐색 시 루프가 발생 가능한 구역인 사이클이 발생할 수 있다.

// 간선의 방향에 따라
// 무방향 그래프
// 간선으로 이어진 정점끼리는 양방향 이동이 가능하다.
// A-B, B-A는 같은 간선이다.
//
// 방향 그래프
// 간선에 방향성이 존재하는 그래프
// 양방향으로 갈 수 있더라도 A-B, B-A는 다른 간선이다.

// 연결 상태에 따라
// 연결 그래프
// 모든 정점이 서로 이동 가능한 그래프
//
// 비연결 그래프
// 특정 정점쌍 사이에 간선이 존재하지 않는 그래프
//
// 완전 그래프
// 모든 정점끼리 연결된 상태인 그래프
// ((모든 정점의 수) - 1) * (모든 정점의 수) = (모든 간선의 수)

// 사이클
// 그래프의 정점과 간선의 부분 집합에서 순환이 되는 부분

// 그래프의 구현
// 인접 행렬(2차원 배열)
// 가중치를 넣고 싶다면 Boolean값 대신 Number와 null을 사용하면 된다.
// 무방향 그래프는 값을 대칭으로 넣어주면 된다. graph[0][1] = true, graph[1][0] = true
const matrixGraph = Array.from(Array(5), () => Array(5).fill(false));
matrixGraph[0][1] = true; // 0 - 1 간선
matrixGraph[0][3] = true; // 0 - 3 간선
matrixGraph[1][2] = true; // 0 - 2 간선
matrixGraph[2][0] = true; // 2 - 0 간선
matrixGraph[2][4] = true; // 2 - 4 간선
matrixGraph[3][2] = true; // 3 - 2 간선
matrixGraph[4][0] = true; // 4 - 0 간선

//인접 리스트(연결 리스트)
const adjacencyGraph = Array.from(Array(5), () => []);
graph[0].push(1); // 0 -> 1
graph[0].push(3); // 0 -> 3
graph[1].push(2); // 1 -> 2
graph[2].push(0); // 2 -> 0
graph[2].push(4); // 2 -> 4
graph[3].push(2); // 3 -> 2
graph[4].push(0); // 4 -> 0
