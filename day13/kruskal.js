// 최소 신장 트리

// 필요한 간선 외에는 전부 제거

// 신장 트리란 그래프 내에 모든 정점을 포함하는 최소 연결 부분 그래프다.
// 최소 신장 트리의 조건
// 1. 최소한의 간선으로 모든 정점 연결
// 2. 모든 신장 트리 중 가중치의 값이 최소
// 3. 사이클이 발생해서는 안 된다.

// 최소 신장 트리 구성을 위한 알고리즘
// 크루스칼(Kruskal)
// 프림(Prim)

// 크루스칼 알고리즘의 구현
// 그리디 개념을 이용해 구현
// 1. 모든 그래프를 부분 집합으로 분리
// 2. 가장 가중치가 낮은 간선을 선택하고 부분 집합을 연결
// - 연결하면서 사이클이 발생하지 않도록 한다
// - 공통 최상위 부모를 찾는 것으로 막을 수 있다.
// - 사이클을 판단하기 위한 알고리즘으로 union-find 알고리즘을 활용할 수 있다.

// union-find 알고리즘
// 서로소 집합을 구하기 위한 알고리즘
// 공통 원소가 없는 두 집합을 표현하기 위한 자료구조
// 보통 트리 구조로 구성한다.
// 편의상 재귀로 구현하는 경우가 많다.
//
// 서로 다른 두 집합을 병합하는 union연산
// 정점 A,B,C,D,E가 있다고 가정하면
// 1. 초기에는 자기 자신을 부모 정점으로 설정, 자기 자신을 자신이 속한 집합으로 설정.
// 2. B가 A에 속할 경우 B의 부모 원소를 A로 바꾼다. 두 원소는 같은 집합이 된다.
// 3. D가 B에 속할 경우 집합의 최상위 원소인 A로 부모 원소를 설정한다. D도 같은 집합이 된다.
// 4. E가 C에 속할 경우 E의 부모 원소를 C로 바꾼다. E는 C와 같은 집합이 된다.
// 5. E가 B에도 속할 경우 B의 최상위 원소인 A로 C의 부모 원소를 정한다.
//
// 집합의 원소가 어떤 집합에 속해 있는지 판단하는 find연산
// 부모가 자기 자신일 때 까지 올라가는 방법 - 편향 트리라면 O(n)의 시간복잡도. 비효율적.
// 이를 해결하기 위해 경로 압축을 이용한다.
// 재귀로 구현했다면 돌아오면서 부모 값을 변경해준다.
// 자연스럽게 경로가 최적화된다. 상수 시간이 소요되게 최적화된다.

// Kruskal 요약
// 가장 가중치가 낮은 간선부터 - Greedy
// 각 원소가 같은 집합인지 확인 - Union-Find
// 두 정점이 같은 집합에 속한다면 사이클 발생하므로 건너뛰기.

function solution(n, costs) {
  let answer = 0;

  // 먼저 정렬부터. 오름차순으로
  const sorted = costs.sort((a, b) => a[2] - b[2]);
  const parent = Array.from({ length: n }, (_, i) => i);

  // 정렬된 간선 순회
  for (const [a, b, cost] of sorted) {
    // 두 원소가 같은 집합이면 사이클이 발생하므로 연결하지 않고 건너뛰기
    if (compare(parent, a, b)) {
      continue;
    }
    // 아니라면 answer에 가중치를 더한다.
    answer += cost;
    // 두 잡합을 하나로 만든다.
    union(parent, a, b);
  }

  return answer;
}

// 최상위 원소 찾기
function find(parent, x) {
  // 부모와 원소가 같다면 최상위 원소
  if (parent[x] === x) {
    return x;
  }
  // 경로 압축 최적화
  return (parent[x] = find(parent, parent[x]));
}

// 두 원소 합치기
function union(parent, a, b) {
  a = find(parent, a);
  b = find(parent, b);
  // 더 낮은 원소가 부모 원소가 되도록
  if (a < b) {
    parent[b] = a;
  } else {
    parent[a] = b;
  }
}

// 두 원소가 같은 집합인지 검사(사이클 방지)
function compare(parent, a, b) {
  a = find(parent, a);
  b = find(parent, b);
  return a === b;
}
